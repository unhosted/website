<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8" />
    <meta name="description" content="weekly handbook about unhosted web apps" />
    <title>unhosted web apps: using Solid</title>
    <link rel="stylesheet" href="/adventures/hljs/default.min.css" />
    <link rel="hub" href="http://pubsubhubbub.appspot.com/"/>
    <link rel="updates alternate" type="application/atom+xml" href="/adventures/feed.atom" />
    <link rel="author" type="text/html" href="http://michielbdejong.com/"/>

    <script src="/adventures/hljs/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <link rel="stylesheet" href="/adventures/adventures.css" />
  </head>

  <body>
    <article>
      <header>
        <h1>unhosted web apps</h1>
        <h2>freedom from web 2.0's monopoly platforms</h2>
      </header>
      
      <h2>using Solid</h2>

 <p>Solid is similar to remoteStorage in that it allows apps and services (including unhosted web apps)
to store the user's data under the user's control. Where it differs from remoteStorage
is in its focus on linked data and its ACL system.</p>
<p>This article describes how you can use Solid to develop an app that allows the user to
connect their Solid pod as the per-user data storage.</p>

<h3>WebId-OIDC</h3>
<p>A WebId is a URL that uniquely identifies a user. Using WebId-OIDC, the app can obtain an
id token which proves that the user currently interacting with the app controls that WebId.
From this id token, a bearer token can be derived. The exact way in which this happens is
changing. The old way is
described in <a href="https://github.com/solid/webid-oidc-spec">the WebID-OIDC spec</a>, and the
new way has not been fully described yet. Solid apps should support both old and now identity providers,
as well as old and new storage providers. But luckily,
as an app developer you can follow for instance 
<a href="https://solidproject.org/for-developers/apps/first-app/1-authentication">this excellent tutorial</a>
and rely on the
  <a href="https://github.com/solid/solid-auth-client">Solid Auth Client</a> library to obtain the id token
for the currently interacting user and produce the bearer token.
</p>
<p>Solid Auth Client will take care of opening a popup window where the user can find their identity provider
from a list, or type in their WebId as a URL. When the token comes back to the app, Solid Auth Client will harvest
it from there, and use it to create a bearer token. You can then use <tt>SolidAuth.fetch</tt> instead of the browser's
built-in
<tt>fetch</tt> function, and it will behave just like the normal fetch, but adding the appropriate Authorization request
header to each request.
</p>

<h3>Web of Personal Data</h3>
<p>Although you could store any data on the user's pod, by convention, personal data is organized in a particular way on
Solid. The starting point for the web of data around the currently interacting user is their
profile document, which is always hosted at the user's WebID, and is always publically readable. A WebId usually
contains a hash, for instance https://michielbdejong.inrupt.net/profile/card#me. The document will be an RDF data source,
giving you (subject, predicate, object) triples in for instance <tt>text/turtle</tt> or <tt>json-ld</tt> representation.
Turtle is pretty easy to read; at the top is a list of prefixes which end in ':', so for instance 'ldp:' is an abbreviation
for 'https://www.w3.org/ns/ldp#'. That means that when you see 'ldp:inbox', it means 'https://www.w3.org/ns/ldp#inbox'.

You pretty much always
want to start by fetching the profile document of the currently logged in user.
From there, you can discover the <tt>ldp:inbox</tt>link to the user's inbox, <tt>solid:privateTypeIndex</tt>>,
<tt>solid:publicTypeIndex</tt>>, and other data.
</p>
<p>The inbox is a folder to which anybody can POST, but only the user themselves can read. It is useful
for sending the user a message. Some domain-specific inboxes also exist in Solid, for instance for
playing Tic-Tac-Toe and for friend requests, messages can be sent either to the user's global inbox, or
to the domain-specific one if it exists.
</p>
<p>
The public and private type indexes lists zero or more <tt>solid:TypeRegistration</tt>s, with <tt>solid:forClass</tt> 
triples pointing to public and private documents that describe an instance
of a specific RDF type. For instance, the public type index might link to a user's public list of bookmarks.
</p>
<p>
This systems makes Solid more flexible than for instance remoteStorage, where private bookmarks always need to be
at /bookmarks, and public ones always need to be at /public/bookmarks. On the other hand, it makes it harder to
do scoped access control. As we'll see in the 'ACL documents' chapter further on, it's possible to give an app
read, append, write, and/or control
access to specific subtrees of the storage. This us generally done by a launcher app, which acts as an auth server,
in that it has full access itself, but edits the access control lists when you're about to use an app that is only
trusted for a certain data domain. The launcher app can also create folders and documents if they're missing, and
add links to them in for instance the private or public type index of the user.
</p>
<p>
A full overview of data that you might find on a user's pod, and how to discover it, is in the client-client spec
which is currently under construction, but a good draft so far can be found in the
<a href="https://github.com/solid/solid-panes/blob/master/Documentation/conventions.md">data conventions</a> of the
Solid databrowser.
</p>
<h3>Read-Write Web</h3>
<p>Reading and writing data is pretty similar to what you would expect if you know a bit about HTTP and you know how
it works for remoteStorage. To read, the usual HEAD and GET verbs can be used. Data is stored hierarchically with files
in folders, which are formally defined as LDP Resources and LDP BasicContainers. There are 4 types of resources: containers
(their URL ends in a forward slash), ACL documents, other RDF sources, and non-RDF resources.

RDF sources (i.e. Containers, ACL documents, and other RDF sources)
can be thought of as not really tied to a <tt>text/turtle</tt> or <tt>json-ld</tt> representation,
since the server is required to convert between at least those two, through content negotiation. So when you retrieve it
requesting a Turtle representation, it's unknown to you whether it was also uploaded in Turtle, or in one of RDF's other
representations.
In the line of this way of thinking about RDF sources separately from their representations, a Solid server may lose formatting
details and comments, even when you store a Turtle file and then retrieve it again as Turtle.
</p>
<p>
The container description used by Solid is
the one from the LDP BasicContainer, so direct children are listed with <tt>ldp:contains</tt> triples.
</p>
<p>All operations on ACL documents act the same way as on other RDF resources, except that they always require Control access
over the resource to which the ACL applies, regardless of whether it's a reading, creating, appending, modifying, or deleting
operation. There is now way to know if a resource is an ACL document, and if it is, there is no way to know to which resource
it applies, except that the resource to which it applies will link
back to it with a Link response header (relation: 'acl').
</p>
<p>HEAD and GET on non-ACL documents both require Read access.</p>
<p>There are two ways to create a new resource: POST and PUT. POST adds a new resource inside a container, and although you
can specify a <tt>Slug</tt> header to influence the resulting location, the server decides the URL at which the resource
will be created. For PUT, the client can choose the location. In both cases, the server will create any ancestor containers on the 
path from the domain root to the URL of the request if they don't exist yet. If a container needs to be created then it
requires Write access on that container and Append or Write access on its parent. A POST request requires Append or Write access on
the container in which
the resource is being created. A PUT does too, but additionally it requires Write access to the URL of the newly created resource
itself. It's not possible to create an empty container, other than by creating a dummy resource inside it (and then deleting that
again).
</p>
<p>
A DELETE of a resource requires Write access to the resource and Write to the container it's in. A container can
only be
deleted if it's empty.</p>
<p>ACL documents and other non-container RDF sources can be edited using a PATCH request with a (restricted) sparql-update body.
  The sparql-update body can include INSERT and DELETE instructions. If one of the DELETE instructions fails, the request fails as
  a whole and is not executed. PATCH requests that contain only INSERTs require either Append or Write. PATCH requests that
  also contain DELETEs require Write + Read. Like for POST and PUT, PATCH will cause all ancestor containers to be created if they
are missing, and the whole operation will fail if permissions are insufficient.</p>

<h3>ACL documents</h3>
<p>An ACL document on a non-container affects only that resource, through the `acl:accessTo` predicate. An ACL document on a container
affects that container through the `acl:accessTo` predicate, but it also affects all its
descendants through the `acl:default` predicate, as long as they don't have their own ACL document. So conversely, if a resource doesn't
have its own ACL document with `acl:accessTo` authorizations,
then the `acl:default` authorizations from the ACL document of the container it's in applies, etcetera until you reach an ancestor container
that does have an ACL document. Only one ACL document ever applies, and rules from different ACL documents are never added together.</p>
<p>If the ACL document that applies directly doesn't have any (matching) `acl:accessTo` authorizations,
or if that ACL document doesn't exist and the first ancestor ACL document that does exist
doesn't have any (matching) `acl:default` authorizations, then all access to that resource is denied ("deny then allow" approach).
</p><p>
Even for an authorization that does apply to the resource in question, there are still three dimensions in which it can grant access.
The first is modes (Read, Append, Write, Control). The previous section mentions
for each operation which access modes are required. Note that if you include Write
then there is no additional effect in also including Append.
The second is agent. There are four ways to add agents:
<ul>
  <li>Using `acl:agent` with a specific WebID that should be granted access</li>
  <li>Using `acl:agentGroup` with a `vcard:Group`, whose members should be granted access</li>
  <li>Using `acl:agentClass` with `acl:AuthenticatedAgent`, meaning any correctly authenticated WebID</li>
  <li>Using `acl:agentClass` with `foaf:Agent`, meaning anyone (public access, no authentication needed)</li>
</ul>
You can add any combination of these, although of course if you add the
third or the last one, then there is no additional effect in also including any
specific WebID's or VCard Groups.
The third dimension is application; for authorizations that include public access
in the agent dimension, all origins are allowed in the application dimension.
If public access is not granted in the agent dimension, then no only the storage server's own (same) origin
is allowed by default in the application dimension. All other origins are only allowed if they are listed
on the Authorization, using the `acl:origin` predicate.
</p>

<h3>Updates</h3>
<p>On each resource, you'll find an `Updates-Via` response header, pointing to a WebSocket server. Connect, and send
  `auth [bearer_token]`, then `sub [url]`. You'll get `ack [url]` back, and then `pub [url]` each time the resource changes.
  A change can be a creation, update, or deletion. If you subscribe to a container, you'll only see creation and deletion of the container
  itself, and changes to its list of `ldp:contains`
  triples, not any changes to the resources it contains.
</p>

<h3>Getting your app listed</h3>
<p>To get your app under the attention of Solid users, send pull requests to https://github.com/inrupt/launcher-exploration/blob/master/src/availableApps.ts
  and to https://github.com/solid/solidproject.org/blob/staging/pages/use-solid/apps.md.
</p>

<h3>Changelog</h3>
<p>     
CHANGELOG since mid-2019:
* globbing, sparql-on-get, and acl:trustedApp were removed.
* servers are in theory allowed to be eventually consistent, although this is not recommended.
* WebSockets-pubsub clients SHOULD now send AUTH, but servers should not require it yet.
* Apps SHOULD support both webid-oidc flows, but IDPs and storage providers SHOULD
still support the old one.
* IDPs are no longer required at the spec level to offer a WebID-TLS bridge (but it can still
cost them customers if they don't)

Changes expected mid-2020:
* auth command will become mandatory
* storage servers should switch to new WebID-OIDC bearer token format.
* IDPs should switch to new WebID-OIDC flow.
</p>    </article>      
	
    <div class="logo">
      <img src="../../img/island-color.png" />
    </div>
    
    <nav>
      <div>

<h4>Overview:</h4>
        <p> i. <a href="/">definition</a></p>
        <p> ii. <a href="/getting-started/">getting started</a></p>
        <p> iii. <a href="/apps/">example apps</a></p>
        <p> iv. <a href="/people/">people</a></p>
        <p> v. <a href="/events/">events</a></p>
        <p> vi. <a href="/tools/">dev tools</a></p>
        <p><strong>vii. using Solid</strong></p>
        <p> viii. <a href="https://groups.google.com/forum/#!forum/unhosted">forum</a></p>

<h4><a href="https://unhosted.org/book/">(all episodes as a book)</a></h4>


<h4>(<a href="https://unhosted.org/book.pdf">.pdf</a>)(<a href="https://unhosted.org/book.epub">.epub</a>)  (<a href="https://unhosted.org/book.mobi">.mobi</a>) </h4>

<h4>Adventures:</h4>
        <p> 1. <a href="/adventures/1/Personal-servers-and-unhosted-web-apps.html">intro</a></p>
        <p> 2. <a href="/adventures/2/An-unhosted-editor.html">editor</a></p>
        <p> 3. <a href="/adventures/3/Setting-up-your-personal-server.html">server</a></p>
        <p> 4. <a href="/adventures/4/WebSockets.html">WebSockets</a></p>
        <p> 5. <a href="/adventures/5/Facebook-and-Twitter-from-nodejs.html">social</a></p>
        <p> 6. <a href="/adventures/6/Controlling-your-server-over-a-WebSocket.html">webshell</a></p>
        <p> 7. <a href="/adventures/7/Adding-remote-storage-to-unhosted-web-apps.html">remoteStorage</a></p>
        <p> 8. <a href="/adventures/8/Collecting-and-organizing-your-data.html">your data</a></p>
        <p> 9. <a href="/adventures/9/Sending-and-receiving-email-from-unhosted-web-apps.html">email</a></p>
        <p> 10. <a href="/adventures/10/Linking-things-together-on-the-world-wide-web.html">web linking</a></p>
        <p> 11. <a href="/adventures/11/App-hosting.html">app hosting</a></p>
        <p> 12. <a href="/adventures/12/App-discovery.html">app discovery</a></p>
        <p> 13. <a href="/adventures/13/Dealing-with-users-in-unhosted-web-apps.html">users</a></p>
        <p> 14. <a href="/adventures/14/Peer-to-peer-communication.html">p2p</a></p>
        <p> 15. <a href="/adventures/15/Unhosted-web-apps-and-OAuth.html">unhosted oauth</a></p>
        <p> 16. <a href="/adventures/16/Our-plan-to-save-the-web.html">save the web</a></p>

<h4>Decentralize:</h4>
        <p> 17. <a href="/decentralize/17/Cryptography.html">cryptography</a></p>
        <p> 18. <a href="/decentralize/18/Distributed-hash-tables.html">dht</a></p>
        <p> 19. <a href="/decentralize/19/BGP,-IP,-DNS,-HTTP,-TLS,-and-NAT.html">internet</a></p>
        <p> 20. <a href="/decentralize/20/Persona,-OpenID,-SAML,-WebID,-and-Webfinger.html">identity</a></p>
        <p> 21. <a href="/decentralize/21/Client-side-sessions,-origins,-browser-tabs,-and-WebIntents.html">browser sessions</a></p>
        <p> 22. <a href="/decentralize/22/How-to-locate-resources.html">search</a></p>
        <p> 23. <a href="/decentralize/23/Network-neutrality,-ubiquitous-wifi,-and-DRM.html">neutrality</a></p>
        <p> 24. <a href="/decentralize/24/Decentralizing-the-web-by-making-it-federated.html">federation</a></p>
        <p> 25. <a href="/decentralize/25/Anonymity.html">anonymity</a></p>
        <p> 26. <a href="/decentralize/26/Decentralized-reputation-systems.html">reputation</a></p>

<h4>Practice:</h4>
        <p> 27. <a href="/practice/27/Persisting-data-in-browser-storage.html">browser storage</a></p>
        <p> 28. <a href="/practice/28/Synchronizing-browser-storage-with-server-storage.html">sync</a></p>
        <p> 29. <a href="/practice/29/Offline-first-web-app-design.html">offline first</a></p>
        <p> 30. <a href="/practice/30/Backend-as-a-Service-platforms.html">baas</a></p>
        <p> 31. <a href="/practice/31/Allowing-the-user-to-choose-the-backend-server.html">per-user backend</a></p>
        <p> 32. <a href="/practice/32/Client-side-libraries-for-per-user-backend.html">per-user clients</a></p>
        <p> 33. <a href="/practice/33/Client-side-frontend-development.html">client-side frontend</a></p>
        <p> 34. <a href="/practice/34/Conclusions.html">conclusions</a></p>
      </div>
      
      <div>
        <h4>Supporters:</h4>
        <p>
          <a class="logo" href="http://nlnet.nl/">
            <img src="../../img/nlnet.png" />
          </a>
          &nbsp;
        </p>

        <p>
          <a class="logo" href="http://wauland.de/">
            <img src="../../img/wau.png" />
          </a>
          &nbsp;
        </p>

        <p>
          <a class="logo" href="http://www.gabrielweinberg.com/blog/2012/03/duckduckgo-foss-donations-2011.html">
            <img src="../../img/duckduckgo.jpg" />
          </a>
          &nbsp;
        </p>

        <p>
          and <a href="../../thankyou.html">many more</a>&hellip;
        </p>
      </div>
    </nav>
    
    <footer>
      <strong>You can follow</strong>
      <img src="../../img/twitter.png" /><a target="_blank" href="https://twitter.com/unhosted">@unhosted</a>
      <strong>on twitter and in</strong>
      <a href="/adventures/1/Personal-servers-and-unhosted-web-apps.html#follow">many other ways</a><strong>. So stay tuned! :)</strong>
      </strong>
    </footer>
  </body>
</html>
